{"version":3,"sources":["Components/SearchBox/SearchBox.module.css","Components/MovieCard/MovieCard.module.css","Container/App.module.css","Components/MovieList/MovieList.module.css","Redux/SearchBox/SearchBox.types.ts","Redux/FilmCard/FilmCard.types.ts","Redux/FilmCard/FilmCard.selectors.ts","Redux/SearchBox/SearchBox.selectors.ts","Components/SearchBox/SearchBox.tsx","Container/SearchBoxPage.tsx","Redux/SearchBox/SearchBox.actions.ts","Redux/FilmCard/FilmCard.actions.ts","Components/MovieCard/MovieCard.tsx","Components/MovieList/MovieList.tsx","Container/MovieListPage.tsx","Container/App.tsx","serviceWorker.js","Redux/FilmCard/FilmCard.reducers.ts","Redux/SearchBox/SearchBox.reducers.ts","Redux/rootReducer.ts","API/Api.tsx","Redux/FilmCard/FilmCard.sagas.ts","Redux/rootSaga.ts","Redux/store.ts","index.tsx"],"names":["module","exports","HANDLE_SEARCH_CHANGE","CLEAR_SEARCH_FIELD","REQUEST_FILM_DATA_START","REQUEST_FILM_DATA_SUCCESS","REQUEST_FILM_DATA_FAILURE","CLEAR_FILM_DATA","selectMoviesList","state","moviesList","selectMovies","createSelector","movies","selectError","error","selectSearchField","searchText","searchField","SearchBox","searchChange","handleSubmit","clearMovies","clearSearchField","className","styles","container","searchContainer","input","type","placeholder","onChange","value","button","onClick","length","icon","role","aria-label","mapStateToProps","createStructuredSelector","connect","dispatch","event","payload","target","fetchFilmDataStart","props","MovieCard","Title","Poster","Year","moviecard","src","alt","image","title","MovieList","undefined","movielist","map","imdbID","App","React","Component","Boolean","window","location","hostname","match","initialState","isPending","rootReducer","combineReducers","action","fetchFilmData","a","axios","get","process","Search","data","fetchFilmDataAsync","watchFetchFilmData","call","response","put","takeLatest","rootSaga","all","fork","sagaMiddleware","createSagaMiddleware","middlewares","logger","store","createStore","applyMiddleware","run","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.f44a0c7e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"SearchBox_container__2VawF\",\"searchContainer\":\"SearchBox_searchContainer__3Vx-T\",\"input\":\"SearchBox_input__7R9fZ\",\"button\":\"SearchBox_button__vdESL\",\"icon\":\"SearchBox_icon__1S6-C\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"moviecard\":\"MovieCard_moviecard__3rhlb\",\"title\":\"MovieCard_title__2YPHA\",\"error\":\"MovieCard_error__3U9cl\",\"image\":\"MovieCard_image__3DaOQ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16_go\",\"App-logo\":\"App_App-logo__14lKf\",\"App-logo-spin\":\"App_App-logo-spin__3lLOM\",\"App-header\":\"App_App-header__1CKgp\",\"App-link\":\"App_App-link__23rLK\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"movielist\":\"MovieList_movielist__1vxse\"};","// Describing the shape of the searchField slice of state\nexport interface ISearchBox {\n  searchField: string;\n}\n\nexport const HANDLE_SEARCH_CHANGE = \"HANDLE_SEARCH_CHANGE\";\nexport const CLEAR_SEARCH_FIELD = \"CLEAR_SEARCH_FIELD\";\n\n// so we are exporting each actions in typescript format\nexport interface handleSearchChange {\n  type: typeof HANDLE_SEARCH_CHANGE;\n  payload: string;\n}\n\nexport interface clearSearchField {\n  type: typeof CLEAR_SEARCH_FIELD;\n}\n\n// here we making the aggregation all these typescript actions\n// for that I am using the union operator or OR  operator.\nexport type SearchBoxActionTypes = handleSearchChange | clearSearchField;\n","    // Describing the shape of the movies  slice of state\n\nexport interface IMovies {\n    [imdbID: string]: string;\n    Title: string;\n    Poster: string;\n    Year: string;\n  }\n  \n  export interface IMoviesList {\n    movies: Array<IMovies>;\n    isPending: boolean;\n    error: string;\n  }\n  \n  export const REQUEST_FILM_DATA_START = \"REQUEST_FILM_DATA_START\";\n  export const REQUEST_FILM_DATA_SUCCESS = \"REQUEST_FILM_DATA_SUCCESS\";\n  export const REQUEST_FILM_DATA_FAILURE = \"REQUEST_FILM_DATA_FAILURE\";\n  export const CLEAR_FILM_DATA = \"CLEAR_FILM_DATA\";\n  \n  // so we are exporting each actions in typescript format\n  \n  export interface fetchFilmDataStartAction {\n    type: typeof REQUEST_FILM_DATA_START;\n    payload: string;\n  }\n  \n  export interface fetchFilmDataSuccessAction {\n    type: typeof REQUEST_FILM_DATA_SUCCESS;\n    payload: Array<IMovies>;\n  }\n  \n  export interface fetchFilmDataFailureAction {\n    type: typeof REQUEST_FILM_DATA_FAILURE;\n    payload: string;\n  }\n  \n  export interface clearFilmDataAction {\n    type: typeof CLEAR_FILM_DATA;\n  }\n  \n  // here we making the aggregation all these typescript actions\n  // for that I am using the union operator or OR  operator.\n  \n  export type FilmCardActionTypes =\n    | fetchFilmDataStartAction\n    | fetchFilmDataSuccessAction\n    | fetchFilmDataFailureAction\n    | clearFilmDataAction;","import { createSelector } from \"reselect\";\nimport { AppState } from \"../store\";\n\nconst selectMoviesList = (state: AppState) => state.moviesList;\n\nexport const selectMovies = createSelector(\n  [selectMoviesList],\n  (moviesList) => moviesList.movies\n);\n\nexport const selectError = createSelector(\n  [selectMoviesList],\n  (moviesList) => moviesList.error\n);","import { createSelector } from \"reselect\";\nimport { AppState } from \"../../Redux/store\";\n\nconst selectSearchText = (state: AppState) => state.searchText;\n\nexport const selectSearchField = createSelector(\n  [selectSearchText],\n  (searchText) => searchText.searchField\n);\n","import React from \"react\";\nimport styles from \"./SearchBox.module.css\";\n\n// here we are going to specify the type of the parameters that\n// SearchBox components have\ninterface ISearchBox {\n  searchChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  clearMovies: () => void;\n  handleSubmit: (searchField: string) => void;\n  clearSearchField: () => void;\n  searchField: string;\n  error: string;\n}\n\nconst SearchBox: React.FC<ISearchBox> = ({\n  searchChange,\n  handleSubmit,\n  clearMovies,\n  searchField,\n  error,\n  clearSearchField,\n}) => {\n  return (\n    <div className={styles.container}>\n      <div className={styles.searchContainer}>\n      <input\n        className={styles.input}\n        type=\"search\"\n        placeholder=\"search movies...\"\n        onChange={searchChange}\n        value={searchField}\n      />\n\n      <button\n        className={styles.button}\n        onClick={() => handleSubmit(searchField)}\n      >\n        Search\n      </button>\n      {searchField.length > 0 || error ? (\n        <span\n          className={styles.icon}\n          role=\"img\"\n          aria-label=\"sheep\"\n          onClick={() => {\n            clearMovies();\n            clearSearchField();\n          }}\n        >\n          &#10060;\n        </span>\n      ) : null}\n      </div>\n    </div>\n  );\n};\n\nexport default SearchBox;\n","import React, { Dispatch } from \"react\";\n\nimport { connect } from \"react-redux\";\nimport {\n  searchChange,\n  clearSearchField,\n} from \"../Redux/SearchBox/SearchBox.actions\";\nimport {\n  fetchFilmDataStart,\n  clearMovies,\n} from \"../Redux/FilmCard/FilmCard.actions\";\n\nimport { createStructuredSelector } from \"reselect\";\nimport { selectError } from \"../Redux/FilmCard/FilmCard.selectors\";\n\nimport { selectSearchField } from \"../Redux/SearchBox/SearchBox.selectors\";\n\nimport { SearchBoxActionTypes } from \"../Redux/SearchBox/SearchBox.types\";\nimport { FilmCardActionTypes } from \"../Redux/FilmCard/FilmCard.types\";\n\nimport { AppState } from \"../Redux/store\";\nimport SearchBox from \"../Components/SearchBox/SearchBox\";\n\n// here we are doing aggregation of all the app action types\n// & use it inside the mapDispatchToProps to dispatch actions.\ntype AppDispatchActions = SearchBoxActionTypes | FilmCardActionTypes;\n\n// here we are going to specify the type of the parameters that\n// SearchBox components have\ninterface ISearchBox {\n  searchChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  clearMovies: () => void;\n  handleSubmit: (searchField: string) => void;\n  clearSearchField: () => void;\n  searchField: string;\n  error: string;\n}\n\nconst SearchBoxPage = (props: ISearchBox) => {\n  return <SearchBox {...props} />;\n};\n\ninterface LinKStateProps {\n  searchField: string;\n  error: string;\n}\n\n// here we are specifying the return type of LinkMapDispatchProps\ninterface LinkMapProps {\n  //  here we are dispatching actions to redux store so that we are not\n  //  returning anything that why we mentioned void\n  searchChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  clearMovies: () => void;\n  handleSubmit: (searchField: string) => void;\n  clearSearchField: () => void;\n}\nconst mapStateToProps = createStructuredSelector<AppState, LinKStateProps>({\n  searchField: selectSearchField,\n  error: selectError,\n});\n\nconst mapDispatchToProps = (\n  // here we are going to specify the type of the total app actions that are going to dispatch to\n  // redux store using the Dispatch keyword from redux & type AppDispatchActions\n  // then we are going to specify the return type of all these total app actions\n  // using the interface LinkMapProps\n  dispatch: Dispatch<AppDispatchActions>\n): LinkMapProps => ({\n  searchChange: (event) => dispatch(searchChange(event.target.value)),\n  clearMovies: () => dispatch(clearMovies()),\n  handleSubmit: (searchField) => dispatch(fetchFilmDataStart(searchField)),\n  // when the user click on the close icon we need to make the\n  // input text empty\n  clearSearchField: () => dispatch(clearSearchField()),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SearchBoxPage);\n","import {\n  HANDLE_SEARCH_CHANGE,\n  CLEAR_SEARCH_FIELD,\n  SearchBoxActionTypes,\n} from \"./SearchBox.types\";\n\n// TypeScript infers that this function is returning SearchBoxAction.\n// in here we need to do two things  one is the type of the parameter\n// and the  second one is to specify return type for each one of these actions\n//(in our case it is the searcnBoxActionTypes ie SEARCHFIELD_CHANGE)\n// so here searchBoxActionTypes  specify  all the possible actions\n// that redux store can take place\nexport const searchChange = (payload: string): SearchBoxActionTypes => ({\n  type: HANDLE_SEARCH_CHANGE,\n  payload,\n});\n\nexport const clearSearchField = (): SearchBoxActionTypes => ({\n  type: CLEAR_SEARCH_FIELD,\n});\n","import {\n    FilmCardActionTypes,\n    CLEAR_FILM_DATA,\n    REQUEST_FILM_DATA_START,\n    REQUEST_FILM_DATA_SUCCESS,\n    REQUEST_FILM_DATA_FAILURE,\n    IMovies,\n  } from \"./FilmCard.types\";\n  // import { fetchFilmData } from \"../../API/API\";\n  \n  // here we are going specify one thing i.e return action type because\n  //the clearMovies is not taking any paramter\n  export const clearMovies = (): FilmCardActionTypes => ({\n    type: CLEAR_FILM_DATA,\n  });\n  \n  // here we are going to specify the type of the parameter & the return action type\n  // here the type of searchField is string & return action is typeof REQUEST_FILM_DATA_START\n  export const fetchFilmDataStart = (\n    searchField: string\n  ): FilmCardActionTypes => ({\n    type: REQUEST_FILM_DATA_START,\n    payload: searchField,\n  });\n  \n  //now here we are going to specify the type of the parameter & the return action type\n  // here the type of data is typeof ArrayObject & return action is typeof  REQUEST_FILM_DATA_SUCCESS,\n  export const fetchFilmDataSuccess = (\n    data: Array<IMovies>\n  ): FilmCardActionTypes => ({\n    type: REQUEST_FILM_DATA_SUCCESS,\n    payload: data,\n  });\n  // here we are going to specify the type of the parameter & the return action type\n  // here the type of error is string & return action is typeof REQUEST_FILM_DATA_FAILURE\n  export const fetchFilmDataFailure = (error: string) => ({\n    type: REQUEST_FILM_DATA_FAILURE,\n    payload: error,\n  });\n  \n  // export const fetchedFilmData = (searchField) => async (dispatch) => {\n  //   dispatch(fetchFilmDataStart());\n  \n  //   try {\n  //     if (searchField.length > 0) {\n  //       const response = await fetchFilmData(searchField);\n  //       dispatch(fetchFilmDataSuccess(response));\n  //     } else {\n  //       throw Error(\"Sorry!!!, Please enter a film name\");\n  //     }\n  //   } catch (error) {\n  //     dispatch(fetchFilmDataFailure(error.message));\n  //   }\n  // };","import React from \"react\";\nimport styles from \"./MovieCard.module.css\";\n\nexport interface IProps {\n  Title?: string;\n  Poster?: string;\n  Year?: string;\n  error?: string | undefined;\n}\n\n// here we are going to specify the type of the parameters\nconst MovieCard: React.FC<IProps> = ({ Title, Poster, Year, error }) => {\n  return Title ? (\n    <div className={styles.moviecard}>\n      <img src={Poster} alt=\"movie-poster\" className={styles.image} />\n      <div className={styles.title}>\n        <h2>{Title}</h2>\n        <p>Year:{Year}</p>\n      </div>\n    </div>\n  ) : (\n    <div className={styles.error}>\n      <p>{error}</p>\n    </div>\n  );\n};\n\nexport default MovieCard;\n","import React from \"react\";\nimport MovieCard from \"../MovieCard/MovieCard\";\nimport styles from \"./MovieList.module.css\";\nimport { IMovies } from \"../../Redux/FilmCard/FilmCard.types\";\n\ninterface IMoviesListProps {\n  movies: Array<IMovies>;\n  error?: string | undefined;\n  searchField: string;\n}\n\nconst MovieList: React.FC<IMoviesListProps> = ({\n  movies,\n  error,\n  searchField,\n}) => {\n  return (error ||movies===undefined) ? (\n    <MovieCard error={error?error:\"Please enter a valid movie name\"} />\n  ) : (\n    <div className={styles.movielist}>\n      {movies &&\n        movies.map(({ imdbID, Title, Poster, Year }) => {\n          return Poster !== \"N/A\" ? (\n            <MovieCard key={imdbID} Title={Title} Poster={Poster} Year={Year} />\n          ) : null;\n        })}\n    </div>\n  );\n};\n\nexport default MovieList;\n","import React from \"react\";\n\nimport { connect } from \"react-redux\";\n\nimport { createStructuredSelector } from \"reselect\";\nimport {\n  selectMovies,\n  selectError,\n} from \"../Redux/FilmCard/FilmCard.selectors\"\nimport { selectSearchField } from \"../Redux/SearchBox/SearchBox.selectors\";\nimport { IMovies } from \"../Redux/FilmCard/FilmCard.types\";\n\nimport { AppState } from \"../Redux/store\";\nimport MovieList from \"../Components/MovieList/MovieList\";\n\ninterface IMoviesListProps {}\n//here we are doing aggregation of all the props types.\ntype propsList = IMoviesListProps & LinkStateProps;\n\nconst MovieListPage: React.FC<propsList> = (props) => {\n  return <MovieList {...props} />;\n};\n\n// here we need to specify the return type of  mapStateToProps.\n\ninterface LinkStateProps {\n  movies: Array<IMovies>;\n  error?: string | undefined;\n  searchField: string;\n}\n\n// here we are going to specify the  type for parameter state & return\n// type of mapStateToProps.\n// createStructuredSelector comes with two variant- one takes App\n//  total state(AppState),Apps ownProps and the return type of mapStateToProps(LinkStateProps)\n// second one comes with App state and the return type of  mapStateToProps\n// here we using the second type\nconst mapStateToProps = createStructuredSelector<AppState, LinkStateProps>({\n  movies: selectMovies,\n  error: selectError,\n  searchField: selectSearchField,\n});\nexport default connect(mapStateToProps)(MovieListPage);\n","import React from \"react\";\nimport styles from \"./App.module.css\";\nimport SearchBoxPage from \"./SearchBoxPage\";\nimport MovieListPage from \"./MovieListPage\";\n\ninterface IAppProps {}\ninterface IAppState {}\n//  here we are mentioning the type of the props and state\n// of a class component\nclass App extends React.Component<IAppProps, IAppState> {\n  render() {\n    return (\n      <div className={styles.App}>\n        <h1>Movie finder</h1>\n        <SearchBoxPage />\n        <MovieListPage />\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import {\n    FilmCardActionTypes,\n    REQUEST_FILM_DATA_START,\n    REQUEST_FILM_DATA_SUCCESS,\n    REQUEST_FILM_DATA_FAILURE,\n    CLEAR_FILM_DATA,\n    IMoviesList,\n  } from \"./FilmCard.types\";\n  \n  //the first thing we need to do specify the type of default state or initial state\n  // for that you have to make sure to import  the types from filmCardActionTypes\n  const initialState: IMoviesList = {\n    movies: [],\n    isPending: false,\n    error: \"\",\n  };\n  // now here we are going to specify the types of the action parameters &\n  // types of the return type\n  export const FilmCardReducer = (\n    state = initialState,\n    action: FilmCardActionTypes\n  ): IMoviesList => {\n    switch (action.type) {\n      case REQUEST_FILM_DATA_START:\n        return {\n          ...state,\n          isPending: true,\n        };\n  \n      case REQUEST_FILM_DATA_SUCCESS:\n        return {\n          ...state,\n          isPending: false,\n          movies: action.payload,\n        };\n  \n      case REQUEST_FILM_DATA_FAILURE:\n        return {\n          ...state,\n          isPending: false,\n          error: action.payload,\n        };\n  \n      case CLEAR_FILM_DATA:\n        return {\n          ...state,\n          movies: [],\n          error: \"\",\n        };\n      default:\n        return state;\n    }\n  };","import {\n  SearchBoxActionTypes,\n  HANDLE_SEARCH_CHANGE,\n  CLEAR_SEARCH_FIELD,\n  ISearchBox,\n} from \"./SearchBox.types\";\n\n// the first thing to  do  specify type for the initial state or the default state.\n// you have to make sure to import the types from the searchBox types.\nconst initialState: ISearchBox = {\n  searchField: \"\",\n};\n\n// now we are going to specify the types for  parameters & return reducer types.\n//Here we need to do two things , the first thing is to do a type\n// for the action for that we need to import searchBoxActionsTypes.\n// second thing is to do specify type for the return type as well\n// in here we return the searchField  so here we need to say ISearchValue.\nexport const searchChangeReducer = (\n  state = initialState,\n  action: SearchBoxActionTypes\n): ISearchBox => {\n  switch (action.type) {\n    case HANDLE_SEARCH_CHANGE:\n      return {\n        ...state,\n        searchField: action.payload,\n      };\n    case CLEAR_SEARCH_FIELD:\n      return {\n        ...state,\n        searchField: \"\",\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from \"redux\";\nimport { FilmCardReducer } from \"./FilmCard/FilmCard.reducers\";\nimport { searchChangeReducer } from \"./SearchBox/SearchBox.reducers\";\n\nconst rootReducer = combineReducers({\n  moviesList: FilmCardReducer,\n  searchText: searchChangeReducer,\n});\n\nexport default rootReducer;\n","\n   \nimport axios from \"axios\";\nconst API_KEY = process.env.REACT_APP_API_KEY;\n\nexport const fetchFilmData = async (searchField: string) => {\n  try {\n    const {\n      data: { Search },\n    } = await axios.get(\n      `http://www.omdbapi.com/?s=${searchField}&apikey=${API_KEY}`\n    );\n    return Search;\n  } catch (error) {\n    return error;\n  }\n};","\nimport { takeLatest, call, put } from \"redux-saga/effects\";\nimport {\n  fetchFilmDataStartAction,\n  REQUEST_FILM_DATA_START,\n} from \"./FilmCard.types\";\nimport { fetchFilmDataSuccess, fetchFilmDataFailure } from \"./FilmCard.actions\";\nimport { fetchFilmData } from \"../../API/Api\";\n\n//now here we are going to specify the type of the parameter & the return action type\nexport function* fetchFilmDataAsync({ payload }: fetchFilmDataStartAction):any {\n  // yield keyword is similar to await keyword it intercepts execution.\n  try {\n    // if (payload.length > 0) {\n    // call is a effect runs a function, it takes two parameters, first is the\n    // function and second parameter is the argument that to pass inside of the function.\n    const response = yield call(fetchFilmData, payload);\n    // put affect is used to dispatch actions to reducer\n    yield put(fetchFilmDataSuccess(response));\n    // } else {\n    //   throw new Error(\"Sorry!!!, Please enter a film name\");\n    // }\n  } catch (error:any) {\n    yield put(fetchFilmDataFailure(error));\n  }\n}\nexport function* watchFetchFilmData() {\n  yield takeLatest(REQUEST_FILM_DATA_START, fetchFilmDataAsync);\n}","import { all, fork } from \"redux-saga/effects\";\nimport { watchFetchFilmData } from \"./FilmCard/FilmCard.sagas\";\n\nexport function* rootSaga() {\n  // fork performs a non-blocking operation on the function passed.\n  // Call affect runs a function. If it returns a promise, pauses the saga\n  // until the promise is resolved.\n  yield all([fork(watchFetchFilmData)]);\n}\n","import { createStore, applyMiddleware } from \"redux\";\n// import thunkMiddleware from \"redux-thunk\";\nimport rootReducer from \"./rootReducer\";\nimport logger from \"redux-logger\";\nimport createSagaMiddleware from \"redux-saga\";\nimport { rootSaga } from \"./rootSaga\";\n\n// here we are grabbing all the state types from different reducers.\nexport type AppState = ReturnType<typeof rootReducer>;\n\nconst sagaMiddleware = createSagaMiddleware();\nconst middlewares = [sagaMiddleware, logger];\n\nconst store = createStore(rootReducer, applyMiddleware(...middlewares));\n\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./Container/App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { Provider } from \"react-redux\";\nimport store from \"./Redux/store\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}